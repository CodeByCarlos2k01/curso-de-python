# Passo a passo simples — criar um **Manager** customizado no Django

1. **Crie o manager** (pode ficar no `models.py` ou num `managers.py`)

   ```py
   from django.db import models

   class PostManager(models.Manager):
       def get_published(self):
           # retorna QuerySet com posts publicados, ordenados do mais novo pro mais antigo
           return self.filter(is_published=True).order_by('-pk')
   ```

2. **Ligue o manager ao `Post`** (no model)

   ```py
   class Post(models.Model):
       # ... campos do model ...
       is_published = models.BooleanField(default=False)
       # substitui objects pelo manager customizado:
       objects = PostManager()
       # opcional: manter o manager padrão também como fallback
       # default_manager = models.Manager()   # (se quiser acessar todos sem filtro)
   ```

3. **Use o método nas views (em vez de repetir `filter(...).order_by(...)`)**

   ```py
   # blog/views.py
   from django.core.paginator import Paginator
   from .models import Post

   def index(request):
       posts_qs = Post.objects.get_published()   # já vem filtrado e ordenado
       paginator = Paginator(posts_qs, 9)
       page = request.GET.get('page')
       page_obj = paginator.get_page(page)
       return render(request, 'blog/index.html', {'page_object': page_obj})
   ```

4. **Vantagens rápidas**

   * Evita repetir `.filter(is_published=True).order_by('-pk')` em todas as views.
   * Centraliza lógica de consulta (quando mudar a regra, altera só no manager).
   * Métodos do manager retornam `QuerySet`, então você pode encadear (`.select_related()`, `.exclude()`, etc).

5. **Opção avançada — manager que sempre retorna só publicados**
   Se preferir um manager que *sempre* aplica o filtro:

   ```py
   class PublishedManager(models.Manager):
       def get_queryset(self):
           return super().get_queryset().filter(is_published=True).order_by('-pk')

   class Post(models.Model):
       # ...
       published = PublishedManager()    # Post.published.all() → só publicados
       objects = models.Manager()        # mantém o manager padrão para outras operações
   ```

   Use `Post.published.all()` quando quiser apenas os publicados; use `Post.objects.all()` para tudo.

6. **Testar**

   * Rode o servidor e verifique a index — deve listar só posts com `is_published=True` e em ordem decrescente.
   * Se mudar a regra (ex.: filtrar por `is_public=True`), altere apenas o método do manager.

7. **Boas práticas**

   * Deixe os métodos do manager **simples e reusáveis** (retornando `QuerySet`).
   * Crie nomes claros (`get_published`, `recent`, `for_author(user)`, etc).
   * Prefira adicionar managers extras (`published = ...`) em vez de sobrescrever `objects` se precisar do acesso ao conjunto completo em outras partes (admin, scripts, etc).

Pronto — com isso você elimina duplicação de consultas e centraliza a lógica de busca de posts publicados. Quer que eu escreva a versão final do `models.py` e a view já pronta pra você copiar/colar?
