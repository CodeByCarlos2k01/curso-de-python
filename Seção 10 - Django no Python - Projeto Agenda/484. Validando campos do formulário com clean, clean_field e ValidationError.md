Aqui está a explicação sobre **validação de campos no Django** simplificada em **passo a passo**:

---

## 1️⃣ Validação básica de um campo específico (`clean_<campo>`)

* Crie um método no seu form chamado `clean_<nome_do_campo>`.
* Ele valida apenas aquele campo específico.
* Use `self.cleaned_data.get('<campo>')` para acessar o valor.
* Para indicar erro:

  * `raise ValidationError("Mensagem de erro")`
  * ou `self.add_error('<campo>', "Mensagem de erro")`

Exemplo:

```python
from django import forms
from django.core.exceptions import ValidationError

class MyForm(forms.ModelForm):
    class Meta:
        model = Contact
        fields = ['first_name']

    def clean_first_name(self):
        first_name = self.cleaned_data.get('first_name')
        if first_name == "ABC":
            raise ValidationError("Não digite ABC neste campo", code='invalid')
        return first_name
```

* **Diferença**:

  * `raise ValidationError` interrompe a execução do método.
  * `add_error` adiciona a mensagem mas continua validando outros campos.

---

## 2️⃣ Validação que depende de mais de um campo (`clean`)

* Crie o método `clean(self)` no form.
* Ele valida valores combinados ou dependentes entre campos.
* Sempre chame `super().clean()` para obter os dados limpos.
* Use `self.add_error('<campo>', "Mensagem")` para associar erros aos campos.

Exemplo:

```python
def clean(self):
    cleaned_data = super().clean()
    first_name = cleaned_data.get('first_name')
    last_name = cleaned_data.get('last_name')

    if first_name and last_name and first_name == last_name:
        self.add_error('first_name', 'Primeiro nome não pode ser igual ao último')
        self.add_error('last_name', 'Primeiro nome não pode ser igual ao último')
```

---

## 3️⃣ Recomendações de uso

* Use `clean_<campo>` para validar **um único campo**.
* Use `clean` para validar **combinações de campos** ou regras do formulário inteiro.
* Prefira `add_error` se quiser **continuar validando outros campos**.
* Sempre **retorne o valor limpo** no `clean_<campo>`:

  ```python
  return cleaned_data['first_name']
  ```

---

✅ Com isso você consegue:

1. Evitar que dados inválidos sejam salvos no banco.
2. Mostrar mensagens de erro específicas para cada campo.
3. Validar campos isoladamente ou combinados de forma eficiente.

---

Se você quiser, posso fazer **um exemplo completo de form com validação de múltiplos campos e mensagens de erro**, pronto para usar no Django.

Quer que eu faça?
