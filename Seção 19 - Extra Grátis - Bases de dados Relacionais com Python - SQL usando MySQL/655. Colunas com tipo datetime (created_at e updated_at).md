Aqui vai a versão **simplificada e detalhada, em passo a passo**, para adicionar campos de data de criação e atualização às tabelas e entender como eles funcionam.

---

# Passo a passo: `created_at` e `updated_at`

## 1) (Opcional) Ajuste de fuso horário no Docker

Se estiver usando MySQL em Docker:

* No `docker-compose.yml`, dentro do serviço do MySQL, adicione:

  * `environment:`

    * `TZ=America/Sao_Paulo` (ou o fuso que preferir)
* Suba novamente o container.

---

## 2) Adicionar os campos na tabela (ex.: `users`)

### Pelo DBBeaver (GUI)

1. Abra a conexão → expanda o banco → **Tables** → clique na tabela (ex.: `users`).
2. Aba **Properties** → **Columns** → **New**:

   * **Nome:** `created_at`
   * **Tipo:** `DATETIME` (ou `TIMESTAMP`)
   * **Nullable:** **NOT NULL**
   * **Default:** `NOW()` / `CURRENT_TIMESTAMP`
3. Ainda em **Columns** → **New**:

   * **Nome:** `updated_at`
   * **Tipo:** `DATETIME` (ou `TIMESTAMP`)
   * **Nullable:** **NOT NULL**
   * **Default:** `NOW()` / `CURRENT_TIMESTAMP`
   * **On Update:** `NOW()` / `CURRENT_TIMESTAMP` (o DBBeaver geralmente mostra um campo “On update”)
4. **Save** (o DBBeaver gerará o `ALTER TABLE` pra você).

### Via SQL (equivalente)

```sql
ALTER TABLE users
  ADD COLUMN created_at DATETIME NOT NULL DEFAULT NOW(),
  ADD COLUMN updated_at DATETIME NOT NULL DEFAULT NOW() ON UPDATE NOW();
```

> Em versões/variações do MySQL, use `CURRENT_TIMESTAMP` no lugar de `NOW()` se preferir.

---

## 3) Testar o comportamento

* **Inserir** um registro **sem** informar datas → `created_at` e `updated_at` recebem a data/hora atual automaticamente.
* **Atualizar** qualquer campo do registro → apenas `updated_at` muda para a data/hora atual; `created_at` fica como estava.
* **Inserir com data/hora manual** → o valor que você passar é respeitado (formato: `YYYY-MM-DD HH:MM:SS`).

  * Se informar só `YYYY-MM-DD`, a hora vira `00:00:00`.

---

## 4) Repetir em outras tabelas (ex.: junção `users_roles`)

Faça o mesmo para tabelas como `users_roles`:

* GUI: repita o processo de **Columns** → `created_at` e `updated_at`.
* SQL:

```sql
ALTER TABLE users_roles
  ADD COLUMN created_at DATETIME NOT NULL DEFAULT NOW(),
  ADD COLUMN updated_at DATETIME NOT NULL DEFAULT NOW() ON UPDATE NOW();
```

> Na primeira inserção, `created_at == updated_at`. Em qualquer alteração posterior, só `updated_at` muda.

---

## 5) Dicas rápidas e observações

* **Por que `NOT NULL` + `DEFAULT NOW()`?**
  Garante que sempre haja valor válido, sem precisar preencher manualmente.
* **DATETIME vs TIMESTAMP:**
  Para este uso, ambos funcionam. `TIMESTAMP` tem faixas e regras de timezone próprias; se der erro de default em versões antigas, prefira `TIMESTAMP` com `DEFAULT CURRENT_TIMESTAMP`.
* **Formato de data:** `YYYY-MM-DD HH:MM:SS`.
* **Cascades (FK):** apagar/atualizar um pai (com `ON DELETE/UPDATE CASCADE`) não altera `created_at`; `updated_at` muda apenas quando o próprio registro é atualizado.

---

## 6) Se der erro

* **Erro com default em `DATETIME`:** troque para `TIMESTAMP` ou use `CURRENT_TIMESTAMP`.
* **Sem campo “On update” no GUI:** edite pelo SQL com `ON UPDATE CURRENT_TIMESTAMP`.

---

Pronto! Com isso você tem `created_at` e `updated_at` funcionando de forma automática em qualquer tabela do seu banco.
