Aqui está a explicação simplificada em **passo a passo** sobre capturar teclas especiais e emitir sinais na calculadora:

---

# Passo a passo: Capturar Enter, Delete e ESC

### 1. Identificar teclas especiais

* Enter → `Qt.Key_Enter` ou `Qt.Key_Return`
* Backspace → `Qt.Key_Backspace` ou `Qt.Key_Delete` (dependendo do teclado/sistema)
* ESC → `Qt.Key_Escape`

---

### 2. Criar Signals para cada ação

* No display, criar Signals:

```python
from PySide6.QtCore import Signal

class Display(QWidget):
    enter_pressed = Signal()
    delete_pressed = Signal()
    esc_pressed = Signal()
```

---

### 3. Capturar o evento da tecla

```python
def keyPressEvent(self, event):
    key = event.key()
```

---

### 4. Emitir Signal de acordo com a tecla

```python
if key == Qt.Key_Enter or key == Qt.Key_Return:
    self.enter_pressed.emit()
elif key == Qt.Key_Backspace or key == Qt.Key_Delete:
    self.delete_pressed.emit()
elif key == Qt.Key_Escape:
    self.esc_pressed.emit()
else:
    if is_empty(event.text()):  # evita passar teclas sem texto
        event.ignore()
```

---

### 5. Conectar os Signals aos métodos da Grid ou Controller

```python
self.display.enter_pressed.connect(self.handle_enter)
self.display.delete_pressed.connect(self.handle_delete)
self.display.esc_pressed.connect(self.handle_esc)
```

* Exemplo de métodos que recebem o sinal:

```python
def handle_enter(self):
    print("Enter pressionado → calcular")

def handle_delete(self):
    print("Delete/Backspace pressionado → apagar caractere")

def handle_esc(self):
    print("ESC pressionado → limpar display")
```

---

### 6. Benefícios

* Captura apenas as teclas desejadas (Enter, Delete, ESC).
* Evita que outras teclas interfiram no display.
* Permite separar **captura de tecla** (Display) e **ações** (Grid/Controller).

---

Se você quiser, posso fazer um **diagrama visual mostrando as teclas, signals e ações**, que ajuda a entender melhor o fluxo.

Quer que eu faça?
