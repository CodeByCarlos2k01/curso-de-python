Aqui está a explicação resumida em **passo a passo** sobre como evitar SQL Injection usando bindings no SQLite:

---

### Passo a passo: evitar SQL Injection com bindings

1. **Problema**

   * Se você coloca valores **direto na string do SQL**, há risco de SQL Injection.
   * Exemplo arriscado:

     ```python
     cursor.execute(f"INSERT INTO customers (name, weight) VALUES ('{user_input}', {weight})")
     ```
   * Um usuário mal-intencionado poderia inserir comandos e comprometer sua base de dados.

2. **Solução: separar comando SQL e valores**

   * Use **placeholders (`?`)** na string SQL.
   * Cada `?` será substituído por um valor seguro.

3. **Exemplo seguro**

   ```python
   comando = "INSERT INTO customers (name, weight) VALUES (?, ?)"
   valores = ("Joana", 4.0)
   cursor.execute(comando, valores)
   connection.commit()
   ```

   * `comando`: contém o SQL com `?` no lugar dos valores.
   * `valores`: uma **tupla** com os valores correspondentes.
   * O SQLite cuida de inserir os valores corretamente, evitando SQL Injection.

4. **O que mudou**

   * Antes: valores e comandos juntos na mesma string → risco de injeção.
   * Agora: valores separados do comando → seguro, mesmo se vierem do usuário.

5. **Observações**

   * O ID auto increment continua funcionando normalmente; não precisa passar valor.
   * Essa técnica também permite inserir múltiplos registros de forma segura usando `executemany`.

---

Se você quiser, posso fazer uma **versão prática completa em Python**, mostrando como criar a tabela e inserir vários registros usando essa forma segura de binding.

Quer que eu faça?
