# Passo a passo: **Sobreposição de métodos** (overriding)

1. **O que é**

   * Sobreposição = você define um método com o **mesmo nome** na subclasse. O método da subclasse “tapa” o da superclasse.

2. **Quando acontece**

   * Se a subclasse tem `def metodo(...)` com mesmo nome da superclasse, ao chamar `obj.metodo()` o Python executa o da subclasse.

3. **Sobrepor completamente (substituir)**

```python
class A:
    def f(self): print("A")

class B(A):
    def f(self): print("B")   # substitui A.f
```

4. **Chamar o método da superclasse (usar parte do comportamento antigo)**

   * Use `super()` para chamar a versão da superclasse e combinar comportamentos:

```python
class B(A):
    def f(self):
        print("antes")
        super().f()           # chama A.f()
        print("depois")
```

* Útil para: adicionar logging, validação, pré/post-processamento, ou estender retorno.

5. **Quando precisa do valor retornado**

```python
class MinhaStr(str):
    def upper(self):
        print("chamou upper")
        resultado = super().upper()   # pega comportamento original
        return resultado + "!"        # modifica e retorna
```

6. **Alternativa (direta) — não recomendada em herança múltipla**

   * Você pode chamar `A.f(self)`, mas isso **ignora MRO** e pode quebrar em hierarquias complexas. Prefira `super()`.

7. **Cadeia de herança (encadeando super)**

```python
class A: 
    def m(self): print("A")
class B(A):
    def m(self):
        print("B")
        super().m()
class C(B):
    def m(self):
        print("C")
        super().m()

C().m()   # Saída: C \n B \n A
```

* `super()` respeita a MRO e permite chamar a próxima implementação na cadeia.

8. **Pontos importantes / boas práticas**

   * Use sobreposição quando precisa **mudar** ou **estender** comportamento de uma superclasse.
   * Use `super()` ao sobrescrever para manter compatibilidade (especialmente com múltipla herança).
   * Se quer **substituir totalmente**, não chame `super()`.
   * Para `__init__`, chame `super().__init__(...)` para inicializar a superclasse.

9. **Resumo rápido (cheat-sheet)**

   * `subclasse.metodo()` → executa o método da subclasse se existir.
   * `super().metodo()` → chama a versão “acima” na cadeia (MRO-safe).
   * `ClassePai.metodo(self)` → funciona, mas **não** gerencia MRO (use com cautela).

Quer que eu faça uns exemplos curtos para você testar (com `print`/retorno) que mostram os três casos — substituir, estender antes/depois, e cadeia com `super()`?
