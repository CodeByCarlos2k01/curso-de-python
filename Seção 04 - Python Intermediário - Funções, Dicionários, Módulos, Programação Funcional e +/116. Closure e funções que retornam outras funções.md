# Passo a passo — **Closures** (funções que retornam funções)

1. **Objetivo**

   * Criar uma função que *gera* outra função personalizada (adiando parte da execução).

2. **Defina a função exterior** (recebe a configuração):

```python
def criar_saudacao(saudacao):
    ...
```

3. **Defina a função interna** (usa a configuração da exterior):

```python
def saudar(nome):
    return f"{saudacao}, {nome}!"
```

4. **Retorne a função interna sem executá-la** (sem parênteses):

```python
def criar_saudacao(saudacao):
    def saudar(nome):
        return f"{saudacao}, {nome}!"
    return saudar    # retorno da função, não sua execução
```

5. **Guarde o retorno numa variável** (isso cria a *função pronta*):

```python
bom_dia = criar_saudacao("Bom dia")
boa_noite = criar_saudacao("Boa noite")
```

6. **Execute a função retornada passando o argumento que falta**:

```python
print(bom_dia("Luís"))    # => "Bom dia, Luís!"
print(boa_noite("Maria")) # => "Boa noite, Maria!"
```

7. **O que é closure — em uma frase**

   * A função interna **lembra** (fecha sobre) o valor `saudacao` da função exterior mesmo depois dela terminar — por isso chamamos isso de *closure*.

8. **Por que usar isso**

   * Evita repetição; gera funções especializadas (fábricas de funções); força menos parâmetros repetidos no código.

9. **Observação prática**

   * Você pode criar quantas variações quiser (`bom_dia`, `boa_noite`, etc.).
   * Se capturar variáveis mutáveis dentro da closure (ex.: numa `for`), atente para comportamento de referência — isso é um detalhe avançado, que veremos depois.

10. **Resumo rápido**

* `criar_saudacao(...)` → retorna uma função que já "sabe" a saudação; você passa o nome só quando for chamar a função retornada.

Quer um exemplo extra (com debug / passo a passo) ou um exercício para praticar?
