# Passo a passo rápido — como executar comandos e trabalhar com o Docker (sem enrolação)

1. **Contexto curto**

   * Docker adiciona complexidade, mas garante que todo mundo rode o projeto com o **mesmo ambiente**.
   * Você terá 2 containers típicos: o do *web* (Django) e o do *db* (Postgres). Use os nomes do seu `docker-compose.yml` (ex.: `web`, `django_app`, `db`, `psql`).

2. **Executar um comando pontual (sem abrir shell)**

   * Substitua `<service>` pelo nome do serviço no seu `docker-compose.yml` (ex.: `web` ou `django_app`):

   ```bash
   docker compose run --rm <service> python -V
   docker compose run --rm <service> python manage.py migrate
   ```

   * `--rm` remove o container temporário depois do comando.

3. **Executar via shell (um comando complexo / com pipes)**

   ```bash
   docker compose run --rm <service> sh -c "echo $PATH; python manage.py makemigrations"
   ```

4. **Entrar interativamente num container já em execução**

   * Primeiro suba o container (background ou não):

   ```bash
   docker compose up -d    # levanta em background
   ```

   * Depois entre no shell do container:

   ```bash
   docker compose exec -it <service> sh
   # dentro do container: python manage.py createsuperuser
   ```

5. **Executar scripts que você colocou em `scripts/`**

   * Torne os scripts executáveis localmente e no Dockerfile: `chmod +x scripts/*.sh` e `RUN chmod +x /scripts/*.sh`
   * Rodar um script direto (path explícito):

   ```bash
   docker compose run --rm <service> ./scripts/collect_static.sh
   ```

   * Se você adicionou `/scripts` ao `PATH` no Dockerfile, dá para chamar só `collect_static.sh`.

6. **Quando precisa *rebuild* (reconstruir a imagem)**

   * Faça rebuild quando alterar: `Dockerfile`, `docker-compose.yml`, `.env` (variáveis que impactam build) ou arquivos que **foram copiados** (`COPY`) para a imagem.
   * Comando:

   ```bash
   docker compose up --build
   ```

   * Se só mudou código (e você montou volumes), **não precisa** rebuildar — apenas `docker compose up` ou reiniciar.

7. **Subir / parar / logs**

   ```bash
   docker compose up          # sobe (em foreground, mostra logs)
   docker compose up -d       # sobe em background
   docker compose down        # para e remove containers da stack
   docker compose logs -f     # seguir logs em tempo real
   docker compose stop        # para sem remover
   ```

8. **Apagar containers e imagens (quando quiser começar do zero)**

   ```bash
   docker ps -a               # listar containers
   docker rm <container_id>   # remover container
   docker images              # listar imagens
   docker rmi <image_id>      # remover imagem
   ```

9. **Dicas e armadilhas comuns**

   * **Host do banco**: dentro do Compose use o **nome do serviço** como host (`DB_HOST=db` ou `DB_HOST=psql`), **não** `localhost`.
   * **Collectstatic / migrate**: inclua `--noinput` para evitar prompts interativos.
   * **Runserver**: use `0.0.0.0:8000` para aceitar conexões externas do host.
   * **Scripts mudados → rebuild?**

     * Se o `Dockerfile` **COPY** os scripts, mudar localmente **exige rebuild**.
     * Se você montou a pasta `scripts/` como **volume** no `docker-compose`, mudanças locais **aparecem sem rebuild**.
   * **Evite rodar dois servers na mesma porta** (pare o container ativo antes de rodar outro `runserver`).

10. **Resumo prático (fluxo normal)**

    * Subir tudo: `docker compose up --build` (primeira vez ou após alterações de build).
    * Desenvolver (sem rebuild): editar código (com volume) → `docker compose up` ou `docker compose restart web`.
    * Rodar comandos esporádicos: `docker compose run --rm <service> python manage.py <comando>` ou `docker compose exec -it <service> sh`.

Se quiser, eu **gero para você** um mini-cheatsheet com os comandos prontos usando os nomes dos serviços do seu `docker-compose.yml` — quer que eu faça isso?
