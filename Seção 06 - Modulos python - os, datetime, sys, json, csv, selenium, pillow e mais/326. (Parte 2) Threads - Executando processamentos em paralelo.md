Aqui está a explicação sobre **threads usando funções em Python** simplificada em **passo a passo**:

---

# Passo a passo: Criando threads com funções

### 1. Criar uma função que será executada na thread

```python
from time import sleep

def vai_demarar(texto, tempo):
    sleep(tempo)          # espera o tempo definido
    print(texto)          # imprime o texto
```

* Recebe **texto** e **tempo** como parâmetros.
* Simula uma tarefa demorada usando `sleep`.

---

### 2. Criar uma thread usando a função

```python
from threading import Thread

t = Thread(target=vai_demarar, args=("Olá mundo!", 2))  # target = função, args = parâmetros
t.start()  # inicia a thread
```

* `start()` executa a função **paralelamente** à thread principal.

---

### 3. Continuar executando código na thread principal

```python
for i in range(5):
    print("Main thread:", i)
    sleep(0.5)
```

* Enquanto a thread `t` dorme, a thread principal continua rodando.

---

### 4. Criar múltiplas threads

```python
t1 = Thread(target=vai_demarar, args=("Thread 1", 5))
t2 = Thread(target=vai_demarar, args=("Thread 2", 1))
t3 = Thread(target=vai_demarar, args=("Thread 3", 2))

t1.start()
t2.start()
t3.start()
```

* Threads podem executar **independentemente** da ordem de início.
* Exemplo: `Thread 2` pode terminar antes de `Thread 1`.

---

### 5. Esperar uma thread terminar (`is_alive`)

```python
t4 = Thread(target=vai_demarar, args=("Thread 4", 3))
t4.start()

while t4.is_alive():
    print("Esperando a Thread 4 terminar...")
    sleep(0.5)

print("Thread 4 acabou!")
```

* `is_alive()` verifica se a thread ainda está rodando.
* Útil para fazer algo **apenas depois que a thread terminar**.

---

### 6. Fazer a thread principal esperar (`join`)

```python
t5 = Thread(target=vai_demarar, args=("Thread 5", 2))
t5.start()
t5.join()  # bloqueia a thread principal até t5 terminar
print("Thread 5 acabou!")
```

* `join()` faz a thread principal **aguardar a thread acabar**.
* Sem `join()`, a thread principal continua executando normalmente (**não bloqueante**).

---

### 7. Observações importantes

* Usar `join()` = código bloqueante.
* Não usar `join()` = threads executam em paralelo, sem bloquear a principal.
* Essa técnica é útil para tarefas demoradas ou independentes, como downloads, cálculos ou botões de interface gráfica.

---

Se você quiser, posso criar um **diagrama visual mostrando a diferença entre `start()`, `is_alive()` e `join()`** para facilitar a compreensão.

Quer que eu faça isso?
