Aqui vai a versão **passo a passo** sobre *escopo em classes*, `self` e onde cada coisa “vive”:

1. Classe tem seu próprio escopo (namespace)

* Tudo que você define **no corpo da classe** (ex.: `especie = "Felino"` ou `def metodo(...):`) pertence à **classe**.
* Acesso: `Animal.especie`.

2. Métodos têm escopo próprio

* Parâmetros e variáveis **criadas dentro do método** existem **só** ali.
* Não dá para usá-las em outro método → dá `NameError`.

3. `self` = a instância atual

* Em métodos de instância, o **1º parâmetro é sempre `self`**.
* Use `self.algo` para criar **atributos da instância** (dados que outros métodos poderão acessar).

4. Inicialize dados no `__init__`

```python
class Animal:
    def __init__(self, nome):
        self.nome = nome      # atributo de instância
```

* Agora qualquer método pode usar `self.nome`.

5. Acesse em outros métodos com `self`

```python
def comendo(self, alimento):
    return f"{self.nome} está comendo {alimento}"
```

6. Crie a instância e chame métodos

```python
leao = Animal("Leão")
print(leao.comendo("maçã"))
```

7. Um método pode chamar outro método

```python
def executar(self, *args, **kwargs):
    return self.comendo(*args, **kwargs)
```

8. Atributo de classe × de instância (rapidinho)

* **Classe**: definido no corpo da classe; é **compartilhado** por todas as instâncias.
* **Instância**: definido via `self.`; é **próprio** de cada objeto.

9. Regras práticas

* Precisa compartilhar dados entre métodos? → use `self.atributo`.
* Só precisa dentro de um método? → use variável local.
* Não tente acessar, em outro método, variáveis locais de um método.
* Quer acessar algo sem instanciar? → use **atributo de classe** ou (mais avançado) `@classmethod` / `@staticmethod`.
