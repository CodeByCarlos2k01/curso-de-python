Aqui vai o passo a passo, direto ao ponto:

1. Atributo de classe

* É declarado “solto” no corpo da classe.
* Acesse assim: `Classe.atributo`. Ex.: `Pessoa.ano_atual`.

2. Método de instância (o normal)

* Define com `def metodo(self, ...)`.
* Precisa de uma instância para chamar: `p1.metodo()`.
* `self` é **a instância**.

3. Quando **não** quero instância

* Às vezes o método deve agir na **classe**, não em um objeto específico.

4. Entre em cena o `@classmethod`

* Decore o método com `@classmethod`.
* O primeiro parâmetro vira `cls` (a **classe**).
* Chame direto: `Classe.metodo(...)` (não precisa de instância).

5. O que dá pra fazer com `cls`

* Acessar atributos de classe.
* **Criar novas instâncias**: `return cls(...)`.

6. Factory Method (construtor alternativo)

```python
class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    @classmethod
    def criar_com_50(cls, nome):
        return cls(nome, 50)

    @classmethod
    def criar_anonimo(cls, idade):
        return cls("Anônima", idade)
```

Uso:

```python
p2 = Pessoa.criar_com_50("Helena")  # idade = 50
p3 = Pessoa.criar_anonimo(25)       # nome = "Anônima"
```

7. Limitação importante

* Dentro de `@classmethod` **não existe `self`** (logo, nada de `self.nome`).
* Você só tem `cls` (a classe).

8. Quando usar `@classmethod`

* Construtores alternativos (“jeitos prontos” de criar o objeto).
* Centralizar regras de criação e evitar repetição/erros.

9. E o `@staticmethod`?

* Não recebe `self` nem `cls`.
* É só uma função “relacionada” à classe. Útil em casos pontuais.

10. Regra de bolso

* **`self` = instância (o objeto pronto).**
* **`cls` = classe (o molde).**
