# Passo a passo simples — começar com Docker (Dockerfile, scripts e docker-compose)

1. **Crie o `Dockerfile` na raiz do projeto**
   Conteúdo mínimo (explicações nos comentários):

   ```dockerfile
   # Dockerfile
   FROM python:3.11-alpine3.18
   LABEL maintainer="Seu Nome <seu@email>"

   # variáveis Python úteis
   ENV PYTHONDONTWRITEBYTECODE=1 \
       PYTHONUNBUFFERED=1 \
       PATH="/scripts:/venv/bin:${PATH}"

   WORKDIR /app

   # dependências do SO (netcat: usado pelo script de espera do Postgres)
   RUN apk add --no-cache gcc musl-dev libpq postgresql-dev netcat-openbsd postgresql-client

   # criar venv e atualizar pip
   RUN python -m venv /venv && /venv/bin/pip install --upgrade pip

   # copiar requirements e instalar dependências Python no venv
   COPY requirements.txt /app/requirements.txt
   RUN /venv/bin/pip install -r /app/requirements.txt

   # copiar código e scripts
   COPY django_app/ /app/django_app/
   COPY scripts/ /scripts/

   # criar usuário não-root e diretórios para static/media
   RUN adduser -D -H -u 1000 appuser \
       && mkdir -p /data/web/static /data/web/media \
       && chown -R appuser:appuser /data /scripts /venv

   RUN chmod +x /scripts/*.sh

   USER appuser
   WORKDIR /app/django_app

   # ao iniciar o container, executa o script que aguarda o Postgres, faz migrate, collectstatic e runserver
   CMD ["commands.sh"]
   ```

2. **Crie a pasta `scripts/` e o arquivo `commands.sh` dentro dela**
   `scripts/commands.sh` (tornar executável):

   ```sh
   #!/bin/sh
   set -e

   echo "Aguardando Postgres em ${DB_HOST}:${DB_PORT}..."
   until nc -z "$DB_HOST" "$DB_PORT"; do
     sleep 0.1
   done
   echo "Postgres está pronto."

   # rodar collectstatic e migrations
   python manage.py collectstatic --noinput
   python manage.py migrate --noinput

   # iniciar servidor (desenvolvimento)
   python manage.py runserver 0.0.0.0:8000
   ```

   > Torne executável: `chmod +x scripts/commands.sh`

3. **Criar `docker-compose.yml` com dois serviços (web + db)**
   Exemplo:

   ```yaml
   version: "3.8"
   services:
     web:
       build: .
       env_file:
         - .env
       ports:
         - "8000:8000"
       depends_on:
         - db

     db:
       image: postgres:15-alpine
       environment:
         POSTGRES_DB: ${DB_NAME}
         POSTGRES_USER: ${DB_USER}
         POSTGRES_PASSWORD: ${DB_PASSWORD}
       volumes:
         - pgdata:/var/lib/postgresql/data

   volumes:
     pgdata:
   ```

   * **Importante:** no seu `.env` defina `DB_HOST=db` (nome do serviço) e `DB_PORT=5432` para o Django conectar ao Postgres do compose.

4. **Adicionar `.dockerignore` (para não copiar venv, git, etc.)**
   Exemplo:

   ```
   .venv/
   __pycache__/
   *.pyc
   .git
   .env
   db.sqlite3
   data/
   ```

5. **Verifique `requirements.txt`**
   Inclua `Django` e o adaptador do Postgres (ex.: `psycopg2-binary>=2.9.6,<2.10`) e outras libs que usar. O `Dockerfile` instala tudo a partir daqui.

6. **Ajustes no `settings.py` do Django**

   * Leia as variáveis do `.env` (já tratado em passos anteriores).
   * Configure `DATABASES` para usar `DB_ENGINE/DB_NAME/DB_USER/DB_PASSWORD/DB_HOST/DB_PORT`.
   * `STATIC_ROOT` e `MEDIA_ROOT` devem apontar para `/data/web/static` e `/data/web/media` (mesmo caminho criado na imagem).

7. **Construir e subir (primeira vez)**

   ```bash
   docker-compose up --build
   ```

   * O serviço `web` vai executar `commands.sh`: aguardar o DB, `collectstatic`, `migrate` e `runserver` em `0.0.0.0:8000`.
   * Acesse: `http://localhost:8000`

8. **Boas práticas / observações rápidas**

   * O `Dockerfile` cria um **usuário não-root** (melhor segurança).
   * O script `commands.sh` é o ponto onde você centraliza `migrate` / `collectstatic` / run.
   * Em produção substitua `runserver` por `gunicorn` e reveja volumes/perm.
   * Se usar `psycopg2` em vez de `psycopg2-binary` talvez precise dos pacotes de compilação (`gcc`, `musl-dev`, `libpq-dev`) — já incluídos no `apk add` do exemplo.
   * Para desenvolvimento com *hot-reload* você pode montar o código via `volumes:` no `docker-compose` (opcional).

---

Se quiser, eu gero para você **os arquivos prontos** (`Dockerfile`, `scripts/commands.sh`, `docker-compose.yml` e `.dockerignore`) com base nesse passo a passo — quer que eu crie?
