# Passo a passo — **Cópia rasa (shallow)** vs **cópia profunda (deep)** em Python

1. **Atribuição (não copia — só referencia)**

   * `b = a` → `b` aponta para **o mesmo** objeto em memória. Modificar `b` altera `a`.

   ```py
   a = {"x": 1}
   b = a
   b["x"] = 10
   print(a["x"])  # 10
   ```

2. **Cópia rasa (shallow copy) — o que faz**

   * `.copy()` (dicionário), `list.copy()` ou `a[:]` (lista) criam um **novo** objeto de primeiro nível, mas **reapontam** referências para objetos mutáveis internos.

   ```py
   d1 = {"n": "Ana", "L": [0,1,2]}
   d2 = d1.copy()
   d2["n"] = "Maria"       # d1 não muda (imutável)
   d2["L"][1] = 99         # d1["L"] muda também (mesma lista!)
   ```

3. **Por que isso acontece**

   * Shallow copy copia os valores “superficiais”. Valores imutáveis (str, int, tuple) são clonados por valor; valores mutáveis (list, dict) são **referenciados**, não duplicados.

4. **Exemplo prático (lista dentro de dict)**

   ```py
   d1 = {"lista": [0,1,2]}
   d2 = d1.copy()         # cópia rasa
   d2["lista"][0] = 9
   print(d1["lista"])     # [9,1,2]  ← mudou também
   ```

5. **Cópia profunda (deep copy) — o que faz**

   * `import copy` → `copy.deepcopy(obj)` percorre e **duplica** todos os níveis (listas, dicts, etc.). Alterar uma cópia profunda não afeta o original.

   ```py
   import copy
   d1 = {"L":[0,1,2]}
   d2 = copy.deepcopy(d1)
   d2["L"][0] = 9
   print(d1["L"])  # [0,1,2]  ← original preservado
   ```

6. **Alternativas e atalhos**

   * Dicionário: `d2 = d1.copy()` (shallow)
   * Lista: `l2 = l1.copy()` ou `l2 = l1[:]` (shallow)
   * Qualquer objeto: `import copy; copy.copy(x)` (shallow) / `copy.deepcopy(x)` (deep)

7. **Quando usar cada um**

   * **Atribuição (`=`)**: quando quer outra referência ao mesmo objeto.
   * **Shallow copy**: quando a estrutura é simples ou você quer reutilizar subobjetos mutáveis. Mais rápida e consome menos memória.
   * **Deep copy**: quando precisa de cópia totalmente independente (níveis aninhados), evitando efeitos colaterais.

8. **Cuidado com desempenho e memória**

   * `deepcopy` pode ser lento e consumir muita memória em estruturas grandes ou profundamente aninhadas. Use com parcimônia.

9. **Resumo rápido (cheat sheet)**

   * `b = a` → referência
   * `b = a.copy()` / `b = a[:]` / `copy.copy(a)` → **shallow**
   * `import copy; b = copy.deepcopy(a)` → **deep**

10. **Dica prática**

* Antes de copiar, pergunte: *preciso que subobjetos mutáveis sejam independentes?* Se sim → `deepcopy`. Caso contrário, prefira `copy()` (mais rápido).

Quer exemplos específicos com listas/dicts aninhados que você esteja usando? Posso gerar um mini-teste para você experimentar.
