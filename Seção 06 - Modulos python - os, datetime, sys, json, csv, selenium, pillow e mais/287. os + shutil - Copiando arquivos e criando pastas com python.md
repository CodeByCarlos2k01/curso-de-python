# Passo a passo (enxuto) — como **copiar pastas/arquivos recursivamente** com segurança

### 1. Planeje e faça backup

1. Sempre **teste antes** em uma pasta pequena.
2. Rode primeiro no modo *dry-run* (apenas imprime o que faria). Nunca execute diretamente numa pasta com dados importantes sem testar.

---

### 2. Importar módulos que vai usar

```python
import os
import shutil
```

---

### 3. Resolver caminhos (expandir `~`)

```python
src = os.path.expanduser('~/Desktop/exemplo')   # origem
dst = os.path.expanduser('~/Desktop/NovaPasta') # destino
```

---

### 4. Criar destino (se não existir)

```python
os.makedirs(dst, exist_ok=True)
```

---

### 5. Estratégia segura para copiar recursivamente

* Use `os.walk(src)` para percorrer todos os diretórios e arquivos.
* Para cada `root` calcule o **caminho relativo** em relação a `src` e junte com `dst` (assim mantém a estrutura).
* Antes de copiar cada arquivo, garanta que o diretório de destino exista (`os.makedirs(..., exist_ok=True)`).
* Use `shutil.copy2(src_path, dst_path)` para copiar arquivo preservando metadados básicos.

---

### 6. Exemplo de função recomendada (com `dry_run`)

```python
import os, shutil

def copy_tree(src, dst, *, dry_run=True, ignore_dotfiles=True):
    src = os.path.expanduser(src)
    dst = os.path.expanduser(dst)
    if dry_run:
        print("DRY RUN — nenhuma alteração será feita.")
    # percorre a árvore
    for root, dirs, files in os.walk(src):
        rel = os.path.relpath(root, src)
        target_dir = os.path.join(dst, rel) if rel != os.curdir else dst

        if dry_run:
            print(f"[MKDIR] {target_dir}")
        else:
            os.makedirs(target_dir, exist_ok=True)

        for name in files:
            if ignore_dotfiles and name.startswith('.'):
                continue
            src_path = os.path.join(root, name)
            dst_path = os.path.join(target_dir, name)
            if dry_run:
                print(f"[COPY] {src_path} -> {dst_path}")
            else:
                os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                shutil.copy2(src_path, dst_path)
```

**Uso:**

```python
# primeiro veja o que vai acontecer:
copy_tree('~/Desktop/exemplo', '~/Desktop/NovaPasta', dry_run=True)

# se tudo OK, execute de fato:
copy_tree('~/Desktop/exemplo', '~/Desktop/NovaPasta', dry_run=False)
```

---

### 7. Alternativa rápida: `shutil.copytree`

* Se **destino não existir** e quiser copiar toda a árvore de uma vez:

```python
shutil.copytree(src, dst)  # falha se dst já existir
```

* Observação: em Python moderno existe `dirs_exist_ok=True` para permitir que `dst` exista (use com cuidado).

---

### 8. Tratamento de erros (boas práticas)

* Envolva a cópia com `try/except` para capturar `PermissionError`, `FileNotFoundError`, `OSError`.
* Registre/mostre erros e continue (ou pare, dependendo do caso).

Exemplo simples:

```python
try:
    shutil.copy2(src_path, dst_path)
except Exception as e:
    print("Erro copiando", src_path, "→", e)
```

---

### 9. Segurança e recomendações finais

* Faça **dry-run** sempre antes.
* Confirme caminhos (`print(src, dst)`) antes de rodar.
* Tome cuidado com: sobrescrever arquivos, permissões, arquivos ocultos (.DS\_Store, Thumbs.db).
* Se for mover (apagar origem), prefira copiar e só depois, manualmente, apagar a origem — jamais automatize apagar sem verificação extra.

---

Se quiser, eu adapto o script para:

* filtrar por extensões (ex.: só imagens),
* pular arquivos grandes,
* mostrar progresso,
* ou usar `shutil.copytree` quando apropriado. Quer que eu gere a versão filtrada?
