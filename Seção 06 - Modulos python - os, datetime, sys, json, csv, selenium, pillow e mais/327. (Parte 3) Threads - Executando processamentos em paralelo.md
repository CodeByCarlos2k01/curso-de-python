Aqui está a explicação sobre **threads e manipulação segura de dados em Python** simplificada em **passo a passo**:

---

# Passo a passo: Evitando problemas com threads e dados compartilhados

### 1. Criar uma classe para gerenciar os dados

```python
class Ingressos:
    def __init__(self, estoque):
        self.estoque = estoque  # quantidade de ingressos disponíveis
```

* `estoque` guarda a quantidade disponível.
* Aqui ainda não estamos usando threads.

---

### 2. Criar um método para comprar ingressos

```python
    def comprar(self, quantidade):
        if self.estoque < quantidade:
            print("Não temos ingressos suficientes")
            return
        self.estoque -= quantidade
        print(f"Você comprou {quantidade} ingresso(s). Ainda temos {self.estoque} em estoque.")
```

* Reduz o estoque apenas se houver ingressos suficientes.
* Caso contrário, imprime mensagem e não altera o estoque.

---

### 3. Testar sem threads

```python
ingressos = Ingressos(10)
ingressos.comprar(3)  # reduz estoque de 10 para 7
ingressos.comprar(8)  # imprime "Não temos ingressos suficientes"
```

---

### 4. Usar threads para compras simultâneas

```python
from threading import Thread

t1 = Thread(target=ingressos.comprar, args=(4,))
t2 = Thread(target=ingressos.comprar, args=(7,))

t1.start()
t2.start()
```

* Threads podem executar o método `comprar` ao mesmo tempo.
* Problema: sem controle, o estoque pode ficar negativo.

---

### 5. Problema: condições de corrida

* Se duas threads acessarem o método ao mesmo tempo, elas podem **passar na verificação do estoque antes de reduzir**, causando valores negativos.
* Exemplo: estoque começa com 10, duas threads compram 7 cada → resultado final: -4 ingressos.

---

### 6. Solução: usar `Lock` para sincronizar threads

```python
from threading import Lock

class Ingressos:
    def __init__(self, estoque):
        self.estoque = estoque
        self.lock = Lock()  # cria um "cadeado" para proteger o método

    def comprar(self, quantidade):
        self.lock.acquire()  # tranca o método
        try:
            if self.estoque < quantidade:
                print("Não temos ingressos suficientes")
                return
            self.estoque -= quantidade
            print(f"Você comprou {quantidade} ingresso(s). Ainda temos {self.estoque} em estoque.")
        finally:
            self.lock.release()  # libera o método
```

* `acquire()` = bloqueia o método para outras threads.
* `release()` = libera o método para outras threads após terminar.
* `try/finally` garante que o lock será liberado mesmo se der `return`.

---

### 7. Testar threads seguras

```python
ingressos = Ingressos(10)

t1 = Thread(target=ingressos.comprar, args=(4,))
t2 = Thread(target=ingressos.comprar, args=(7,))

t1.start()
t2.start()
```

* Agora o estoque nunca fica negativo.
* Cada thread aguarda sua vez de acessar o método.

---

✅ **Resumo do passo a passo:**

1. Criar uma classe para os dados compartilhados (`Ingressos`).
2. Criar método que manipula os dados (`comprar`).
3. Testar o método sem threads.
4. Criar threads para executar o método simultaneamente.
5. Identificar problemas de **condição de corrida**.
6. Usar `Lock` para proteger o método (`acquire()` e `release()`).
7. Testar novamente com threads seguras.

---

Se você quiser, posso fazer um **diagrama visual mostrando como várias threads acessam o método e como o Lock impede conflitos**. Isso ajuda muito a entender.

Quer que eu faça isso?
