Aqui está a explicação sobre **decoradores de classes em Python** simplificada em um passo a passo:

---

### 1. **Problema inicial**

* Criamos classes (`Time`, `Planeta`) e instâncias delas.
* Ao dar `print` nas instâncias, Python só mostra o tipo e endereço de memória.
* Queremos um **wrapper** para mostrar o conteúdo de forma amigável.

---

### 2. **Criando um wrapper manual**

```python
def wrapper(cls):
    class_name = cls.__name__
    class_dict = cls.__dict__
    return f"{class_name}({class_dict})"
```

* A função recebe a classe, pega o nome e o `dict` com atributos/métodos.
* Retorna uma string formatada mostrando o conteúdo da classe.

---

### 3. **Problema de repetição**

* Se aplicamos o mesmo wrapper em várias classes, repetimos código.
* **Solução 1:** Herança múltipla com `Mixin`.

```python
class MyWrapperMixin:
    def wrapper(self):
        return f"{self.__class__.__name__}({self.__dict__})"
```

* Classes herdam do mixin e ganham o método wrapper.
* Desvantagem: aumenta a complexidade da herança.

---

### 4. **Solução mais elegante: função decoradora**

* Criamos uma função que **decora a classe** dinamicamente:

```python
def adiciona_wrapper(cls):
    def wrapper(self):
        return f"{self.__class__.__name__}({self.__dict__})"
    cls.wrapper = wrapper
    return cls
```

* Recebe a classe, adiciona o método `wrapper` e retorna a própria classe decorada.
* Pode ser aplicada a qualquer classe sem usar herança.

---

### 5. **Aplicando o decorador**

```python
@adiciona_wrapper
class Time:
    def __init__(self, nome):
        self.nome = nome

@adiciona_wrapper
class Planeta:
    def __init__(self, nome):
        self.nome = nome
```

* O `@adiciona_wrapper` é **açúcar sintático** para aplicar a função decoradora.
* Python passa automaticamente a classe para a função e substitui pela classe decorada.

---

### 6. **Usando o wrapper**

```python
brasil = Time("Brasil")
terra = Planeta("Terra")

print(brasil.wrapper())  # Time({'nome': 'Brasil'})
print(terra.wrapper())   # Planeta({'nome': 'Terra'})
```

---

### 7. **Resumo do fluxo**

1. Criamos a função decoradora que recebe a classe.
2. Adicionamos métodos ou atributos à classe dentro da função.
3. Retornamos a mesma classe decorada.
4. Aplicamos o decorador com `@nome_do_decorador`.
5. Todas as instâncias da classe agora têm o método/atributo decorado.

---

Se você quiser, posso fazer **um esquema visual mostrando a diferença entre mixin, wrapper manual e decorador de classe**, para ficar bem fácil de entender o fluxo. Quer que eu faça?
