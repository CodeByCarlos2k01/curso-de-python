Aqui está a explicação sobre **decoradores no Python** resumida em **passo a passo**:

---

### 1. **O que são decoradores**

* Decoradores são **um açúcar sintático do Python**.
* Eles facilitam o uso de **funções decoradoras**, permitindo aplicar alterações a uma função **sem precisar criar novas variáveis ou chamar manualmente a decoradora**.

---

### 2. **Como funciona o decorador**

1. Você já tem uma **função decoradora** criada (ex.: `criar_funcao`).
2. Para aplicar o decorador a outra função, você **coloca um `@decorador` acima da definição da função**:

```python
@criar_funcao
def inverte_string(s):
    return s[::-1]
```

* Isso é equivalente a:

```python
inverte_string = criar_funcao(inverte_string)
```

* O Python faz esse processo automaticamente, substituindo a função original pela versão decorada.

---

### 3. **O que acontece com a função decorada**

* A função original continua existindo **como objeto interno** dentro da closure criada pela decoradora.
* Você pode:

  * Executar código **antes ou depois** da função.
  * **Alterar o resultado** da função.
  * **Levantar exceções ou validar parâmetros**.

---

### 4. **Exemplo visual**

```python
def criar_funcao(func):
    def interna(*args, **kwargs):
        print("Antes de executar a função")
        resultado = func(*args, **kwargs)
        print("Depois de executar a função")
        return resultado
    return interna

@criar_funcao
def inverte_string(s):
    return s[::-1]

print(inverte_string("Luis"))
```

**Saída:**

```
Antes de executar a função
Depois de executar a função
siuL
```

* O decorador executa automaticamente o que você definiu **antes e depois da função**.

---

### 5. **Vantagens do açúcar sintático (`@decorator`)**

* Não precisa criar uma nova variável manualmente.
* Mantém o **nome da função original**.
* Aplica mudanças de forma **limpa e automática**.
* Permite **alterar comportamento, validar parâmetros e modificar resultados** sem mexer no corpo original da função.

---

Se quiser, posso fazer um **diagrama simples mostrando o fluxo: função → decorador → função decorada**, que ajuda muito a visualizar como o Python substitui a função internamente.

Quer que eu faça?
